#!/bin/bash

#######################################################################################
# read input string, check for new/old images and build log pages test

declare -a logPageTemplateArray
declare -a engineLogsTemplateArray
declare -a imgFiles
declare -a imgCatagories

# function that prints a specified number of specified characters
printf_new() {
 str=$1
 num=$2
 v=$(printf "%-${num}s" "$str")
 echo "${v// /$str}"
}

# parse any inputs on the command line (filename containing metadata)
while :; do
    case $1 in

        -n|--new) # New - make a new Log Page and add to other pages
                  #     - kdx175.Engine.Prep_for_engine_removal.Log.20190714.0900.Main_Shop
            shift
            NEWLOGPAGE="$1"
            printf "\nNew Log Page will be created: $NEWLOGPAGE\n\n"
            ;;
        *)  # Default case: If no more options then break out of the loop.
            break
    esac
done

# break input on each "." and read into array
IFS='.' read -r -a array <<< "$NEWLOGPAGE"

# remove any underscores from the title
n=0
for element in "${array[@]}"
do
    #echo "$element"
    if [ $n -eq 4 ]; then
      logTitle=$element
      logTitleSpaced=${logTitle//_/ }
      #echo $logTitleSpaced
    fi
    let "n++"
done

# read in the names of any new images based on naming convention, e.e. 20190922_000_IMG987.jpeg
cd ./source/_static/images
imgFiles=([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]_[0-9][0-9][0-9].*)
cd ../../..
#printf "%s\n" "${imgFiles[@]}"

# check to see if any new images were actually found
# if the first aray element contains the match string, then no new images were found
# conversely, if the first array element does not contain the match string, a new image was found
if ! [[ ${imgFiles[0]} == "[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]_[0-9][0-9][0-9].*" ]]; then

  # sort the new images
  IFS=$'\n' imgFilesSorted=($(sort <<<"${imgFiles[*]}")); unset IFS
  #printf "%s\n" "${imgFilesSorted[@]}"

  ifcnt=0
  for sectionImage in "${imgFilesSorted[@]}"
  do
    # if a video metadata file
    if [[ ${imgFileSplit[1]} =~ /txt^/ ]]; then
      echo "future: video file optionsectionImage"

    # else if an image filesectionImage
    else
      # shrink large images to a max of 1024
      # todo: add check so that resize is applied only to large images
      #   https://stackoverflow.com/questions/38254297/bash-script-find-all-images-and-mogrify-images#38254569
      mogrify -path ./source/_static/images/ -resize "1024x1024" -quality 70 "./source/_static/images/${sectionImage}"

      # new_image_file_name = new_log_page_name.image_file_name
      imgFileName=$NEWLOGPAGE^${sectionImage}

      # rename the image from the original upload name to the new name
      [ -f "./source/_static/images/${sectionImage}" ] && mv "./source/_static/images/${sectionImage}" "./source/_static/images/${imgFileName}"
      # old, remove mv "./source/_static/images/${sectionImage}" "./source/_static/images/${imgFileName}"
    fi
  done
else
  # use the stock photo (ooo.jpeg) if no photos were uploaded
  imgFileName="$NEWLOGPAGE^000.jpeg"
  #echo "imgFileName = ${imgFileName}"
  cp "./source/_static/images/000.jpeg" "./source/_static/images/${imgFileName}"

  echo "No New Images - using stock photo"
  echo
fi

# all new images have now been renamed - read in the names of all of the images (new and old)
cd ./source/_static/images
imgFilesRenamed=(${NEWLOGPAGE}*)
cd ../../..

# sort the images (new and old)
IFS=$'\n' imgFilesRenamedSorted=($(sort <<<"${imgFilesRenamed[*]}")); unset IFS
#printf "%s\n" "${imgFilesRenamedSorted[@]}"

### disabled during development
#######################################################################################
# create the new Log Page file if it does not already exist
#  if it exists, delete manually and then re-run this script
# todo: add in menu choice (from zfs install)

### disable during development
#### check file existence
###if [ -f source/$NEWLOGPAGE.rst ]
###then
###    echoasdasd
###    echo The file exists: ./source/$NEWLOGPAGE.rst
###    echo Delete and try again
###    echo
###    exit 1
###fi

# No existing file so load the Log File template
# Load the Log Page template file into array.
readarray -t logPageTemplateArray < log_page_template.txt

# save the current Log file (if it exists)
[ -f ./source/$NEWLOGPAGE.rst ] && mv ./source/$NEWLOGPAGE.rst ./source/$NEWLOGPAGE.rst.bak

# cycle through the Log Page template and write out to the Log file substitutung values
let i=0
while (( ${#logPageTemplateArray[@]} > i )); do
    templateOut=${logPageTemplateArray[i]}

    # replace marker with Title Tags (these are Sphinx include markers)
    if [[ $templateOut =~ "zzzTitleTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Title}
      echo "${templateOut//zzzTitleTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Title
    elif [[ $templateOut =~ "zzzTitlezzz" ]]; then
      echo "${templateOut//zzzTitlezzz/$logTitleSpaced}" >> ./source/$NEWLOGPAGE.rst
      printf_new "=" ${#logTitleSpaced} >> ./source/$NEWLOGPAGE.rst

    # replace marker with Log Link Tags (these are Sphinx include markers)
    elif [[ $templateOut =~ "zzzLogLinkTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Log_Link}
      echo "${templateOut//zzzLogLinkTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Log Page name
    elif [[ $templateOut =~ "zzzLogPageNamezzz" ]]; then
      echo "${templateOut//zzzLogPageNamezzz/$NEWLOGPAGE}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Teaser Test Tags (these are Sphinx include markers)
    elif [[ $templateOut =~ "zzzTeaserTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Teaser}
      echo "${templateOut//zzzTeaserTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # build the teaser table with image
    # replace marker with Teaser image or video
    elif [[ $templateOut =~ "zzzTeaserImagezzz" ]]; then

      # evaluate the file extension to determine if image or video metadata file
      # note that image 000 is always used for the teaser table
      IFS='.' read -r -a imgFileSplit <<< "${imgFilesRenamedSorted[0]}"
      # why was this here??
      #IFS=', ' read -r -a imgFileSplit <<< "${imgFilesRenamedSorted[0]//./ }"

      # if a video metadata file
      if [[ ${imgFileSplit[7]} =~ /txt^/ ]]; then
        echo "future: video file option"

      # else if an image file
      else
        # generate a new name for the image file
        # assume that the new files are name sequentially e.g. 000_*, 001_*, etc
        # todo: build name from date/time/OEM_name and/or metadata from thje pic ie 201909140901_IMG9327
        #       this will allow sort by date in the image viewer

        # new_image_file_name = new_log_page_name.image_file_name
        imgFileName=${imgFilesRenamedSorted[0]}

        # get the length of the new image name
        imgFileNameLength=${#imgFileName}

        # calculate the number of spaces needed to add to the name in order to make a legal table row
        spaceLength=$((120-${imgFileNameLength}))
        spaceLengthVar=$(printf ' %.0s' {$(seq 1 $spaceLength)})

        # print the new table row to the new log file
        echo "${templateOut//zzzTeaserImagezzz/$imgFileName}${spaceLengthVar}|" >> ./source/$NEWLOGPAGE.rst

        # todo - remove the next 2 lines
        # rename the image from the original upload name to the new name
        #mv "./source/_static/images/${imgFilesSorted[0]}" "./source/_static/images/${imgFileName}"
      fi

    # replace marker with link to full-sized teaser image
    elif [[ $templateOut =~ "zzzTeaserILinkzzz" ]]; then
      echo "${templateOut//zzzTeaserILinkzzz/$imgFileName}${spaceLengthVar}|" >> ./source/$NEWLOGPAGE.rst

    # replace marker with a new section with an image or video
    elif [[ $templateOut =~ "zzzImageSectionzzz" ]]; then
      k=0

      for sectionImage in "${imgFilesRenamedSorted[@]}"
        do
          if [[ $k -gt 0 ]]; then
            echo "$k"
            echo "$sectionImage"

            # shrink large images to a max of 1024
            # todo: add check so that resize is applied only to large images
            #   https://stackoverflow.com/questions/38254297/bash-script-find-all-images-and-mogrify-images#38254569
            ###mogrify -path ./source/_static/images/ -resize "1024x1024" -quality 70 "./source/_static/images/${sectionImage}"

            # if a video metadata file
            if [[ ${imgFileSplit[7]} =~ /txt^/ ]]; then
              echo "future: video file option"

            # else if an image file
            else
              # new_image_file_name = new_log_page_name.image_file_name
              imgFileNameRtd=${sectionImage}

              # print the new section to the new log file
              echo "" >> ./source/$NEWLOGPAGE.rst

              # extract oem image file name to use for temporary title
              # break image name read from file system on each "^" and read into array
              IFS='^' read -a arrayTitle <<< "$imgFileNameRtd"; unset IFS
              titleFor="Section for your image ${arrayTitle[1]}"
              echo ${titleFor} >> ./source/$NEWLOGPAGE.rst
              printf_new "-" ${#titleFor} >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo ".. figure:: ./_static/images/${imgFileNameRtd}" >> ./source/$NEWLOGPAGE.rst
              echo "   :scale: 50%" >> ./source/$NEWLOGPAGE.rst
              echo "   :alt: ${sectionImage}" >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo "Caption for the image goes here" >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo "   The legend consists of all elements after the caption.  In this" >> ./source/$NEWLOGPAGE.rst
              echo "   case, the legend consists of this paragraph." >> ./source/$NEWLOGPAGE.rst
              
              # rename the image from the original upload name to the new name
              #mv "./source/_static/images/${sectionImage}" "./source/_static/images/${imgFileName}"

              echo $imgFileNameRtd
            fi
          fi
          let "k++"
        done
    elif [[ $templateOut =~ "zzzTagPartsRowszzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Parts}
      echo "${templateOut//zzzTagPartsRowszzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    else
      echo "$templateOut" >> ./source/$NEWLOGPAGE.rst
    fi
  let "i++"
done


#############################################################################################################
# overwrite each category Logs Page file if that category has a new log (this way, any new Logs are included)

# Load the Engine Logs template file into array.
readarray -t engineLogsTemplateArray < engine_logs_template.txt

# read in Log file names
cd ./source
logFiles=(*\.Log\.*q.rst)
cd ..
#echo "${logFiles[@]}"

# sort array of Log file names
IFS=$'\n' logFilesSorted=($(sort <<<"${logFiles[*]}")); unset IFS
#printf "%s\n" "${logFilesSorted[@]}"

# fill array with the categories
n=0
for element in "${logFilesSorted[@]}"
  do
    # break input on each "."
    IFS='.' read -r -a arrayLogs <<< "$element"

    # read each category and insert into new array element
    imgCatagories[$n]=${arrayLogs[3]}
    let "n++"
  done

# remove duplicates from the array
readarray -td '' imgCatagoriesDeduped < <(
  printf '%s\0' "${imgCatagories[@]}" | LC_ALL=C sort -zu)
#echo ${imgCatagoriesDeduped[@]}

# for each category in de-duped array
n=0
for currentCategory in "${imgCatagoriesDeduped[@]}"
  do
  #echo ${currentCategory}

  # save the current Category Logs file (if it exists)
  [ -f ./source/${currentCategory}_logs.rst ] && mv ./source/${currentCategory}_logs.rst ./source/${currentCategory}_logs.rst.bak

  # Explicitly write the first 9 lines of the template out to the Category Logs file
  let i=0
  while (( i < 9 )); do
    templateOut=${engineLogsTemplateArray[i++]}
    echo "$templateOut" >> ./source/${currentCategory}_logs.rst
  done
  #echo ${logFilesSorted[@]}
  
  # for each Log File name already read in, act on those in the current category
  n=0
  for currentLogFileName in "${logFilesSorted[@]}"
    do
      # break input on each "."
      IFS='.' read -r -a currentLogFileNameParts <<< "$currentLogFileName"

      # read each category and insert into new array currentCategory
      currentLogCategory=${currentLogFileNameParts[3]}
      currentLogTitleUnSpaced=${currentLogFileNameParts[4]}

      # remove any underscores from the title
      currentLogTitleSpaced=${currentLogTitleUnSpaced//_/ }
      #echo $currentLogTitleSpaced
      currentLogDate=${currentLogFileNameParts[0]}
      currentLogDateLong=$(date -d $currentLogDate +"%d-%b-%Y")

      # verify during testing
      #echo currentLogCategory=$currentLogCategory
      #echo currentLogTitleSpaced=$currentLogTitleSpaced
      #echo currentLogDateLong=$currentLogDateLong

      # if the current log category matches the log category extracted from the title of the current file
      if [[ ${currentLogCategory} == ${currentCategory} ]]; then
        # append info for each Logs section starting e.g. Engine category
        # append new Log file info to the currentLogCategory Logs file (e.g. Engine Logs)
        currentLogTitleComplete="$currentLogDateLong --- $currentLogTitleSpaced"
        echo "$currentLogTitleComplete" >> ./source/${currentCategory}_logs.rst

        # draw line under title
        printf_new "-" ${#currentLogTitleComplete} >> ./source/${currentCategory}_logs.rst
        echo >> ./source/${currentCategory}_logs.rst

        # old method of determing title
        ## insert include, start, end into the currentLogCategory Logs file for: Title
        #currentLogFileNameUpdated=${currentLogFileName//Log/Title}
        #currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
        #echo ".. include:: ${currentLogFileName}" >> ./source/${currentCategory}_logs.rst
        #echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        #echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        #echo >> ./source/${currentCategory}_logs.rst
        #echo >> ./source/${currentCategory}_logs.rst

        # insert include, start, end into the currentLogCategory Logs file for: Log Link
        currentLogFileNameUpdated=${currentLogFileName//Log/Log_Link}
        currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
        echo ".. include:: ${currentLogFileName}" >> ./source/${currentCategory}_logs.rst
        echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        echo >> ./source/${currentCategory}_logs.rst
        echo >> ./source/${currentCategory}_logs.rst

        # insert include, start, end into the currentLogCategory Logs file for: Teaser
        currentLogFileNameUpdated=${currentLogFileName//Log/Teaser}
        currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
        echo ".. include:: ${currentLogFileName}" >> ./source/${currentCategory}_logs.rst
        echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logs.rst
        echo >> ./source/${currentCategory}_logs.rst
        echo >> ./source/${currentCategory}_logs.rst

        #echo currentLogFileName=${currentLogFileName}
        #echo currentLogFileNameUpdated=${currentLogFileNameUpdated}

      fi

      let "n++"
    done
  done


#############################################################################################################
# overwrite the index page to include category listings and teasers for the log files, sorted by date

# Load the index template file into array.
readarray -t indexTemplateArray < index_template.txt

# read in Log file names
cd ./source
logFiles=(*\.Log\.*q.rst)
cd ..
#echo "${logFiles[@]}"

# sort array of Log file names
IFS=$'\n' logFilesSorted=($(sort <<<"${logFiles[*]}")); unset IFS
#printf "%s\n" "${logFilesSorted[@]}"

# fill a new array with the categories
n=0
for element in "${logFilesSorted[@]}"
  do
    # break input on each "."
    IFS='.' read -r -a arrayLogs <<< "$element"

    # read each category and insert into new array element
    imgCatagories[$n]=${arrayLogs[3]}
    let "n++"
  done

# remove duplicates from the array
readarray -td '' imgCatagoriesDeduped < <(
  printf '%s\0' "${imgCatagories[@]}" | LC_ALL=C sort -zu)
#echo ${imgCatagoriesDeduped[@]}

# capture project name from any of the rows
currentProject=${arrayLogs[2]}

# there is only one index file so write constants before looping
  # save the current Category Logs file (if it exists)
  [ -f ./source/index.rst ] && mv ./source/index.rst ./source/index.rst.bak

  # Explicitly write the first 5 lines of the template out to the index file
  let i=0
  while (( i < 5 )); do
    templateOut=${indexTemplateArray[i++]}
    echo "$templateOut" >> ./source/index.rst
  done
  #echo ${logFilesSorted[@]}

  # build title and insert into index page
  currentIndexTitleComplete="Project: $currentProject"
  echo "$currentIndexTitleComplete" >> ./source/index.rst

  # draw a line of "=" under title
  printf_new "=" ${#currentIndexTitleComplete} >> ./source/index.rst
  
# insert toc into index page
echo "" >> ./source/index.rst
echo ".. toctree::" >> ./source/index.rst
echo "   :maxdepth: 1" >> ./source/index.rst
echo "   :hidden:" >> ./source/index.rst
echo "   :caption: Logs:" >> ./source/index.rst
echo "" >> ./source/index.rst

# insert Category Logs into the TOC section on the index page
for currentCategory in "${imgCatagoriesDeduped[@]}"
  do
  echo "   ${currentCategory}_logs" >> ./source/index.rst
  done

echo "   parts_logs" >> ./source/index.rst
echo "   photos" >> ./source/index.rst
echo "" >> ./source/index.rst

# list the teaser for each Log file, ordered by date
#echo ${logFilesSorted[@]}

# cycle through each Log file
n=0
for currentLogFileName in "${logFilesSorted[@]}"
  do
    # break input on each "."
    IFS='.' read -r -a arrayLogs <<< "$currentLogFileName"

    # read each category and insert into new array currentLogFileName
    imgCatagories[$n]=${arrayLogs[3]}

    #echo $currentLogFileName
    #echo ${imgCatagories[@]}

    # extract the Title from the current Log file and insert it into the index file
    echo ".. include:: ${currentLogFileName}" >> ./source/index.rst
    currentLogFileNameUpdated=${currentLogFileName//Log/Title}
    currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
    echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "" >> ./source/index.rst

    # extract the Log_Link from the current Log file and insert it into the index file
    echo ".. include:: ${currentLogFileName}" >> ./source/index.rst
    currentLogFileNameUpdated=${currentLogFileName//Log/Log_Link}
    currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
    echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "" >> ./source/index.rst

    # extract the Teaser from the current Log file and insert it into the index file
    echo ".. include:: ${currentLogFileName}" >> ./source/index.rst
    currentLogFileNameUpdated=${currentLogFileName//Log/Teaser}
    currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}
    echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/index.rst
    echo "" >> ./source/index.rst

    echo "----" >> ./source/index.rst
    echo "" >> ./source/index.rst

    let "n++"
  done

echo "footer" >> ./source/index.rst
