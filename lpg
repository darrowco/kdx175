#!/bin/bash

#######################################################################################
# read input string, check for new/old images and build log pages

declare -a logPageTemplateArray
declare -a engineLogsTemplateArray
declare -a imgFiles
declare -a imgCatagories

printf_new() {
 str=$1
 num=$2
 v=$(printf "%-${num}s" "$str")
 echo "${v// /$str}"
}

# parse any inputs on the command line
while :; do
    case $1 in

        -n|--new) # New - make a new Log Page and add to other pages
                  #     - kdx175.Engine.Prep_for_engine_removal.Log.20190714.0900.Main_Shop
            shift
            NEWLOGPAGE="$1"
            printf "\nNew Log Page will be created: $NEWLOGPAGE\n"
            ;;
        *)        # Default case: If no more options then break out of the loop.
            break
    esac
done

# break input on each "." and read into array
IFS='.' read -r -a array <<< "$NEWLOGPAGE"

# remove any underscores from the title
n=0
for element in "${array[@]}"
do
    echo "$element"
    if [ $n -eq 2 ]; then
      logTitle=$element
      logTitleSpaced=${logTitle//_/ }
      echo $logTitleSpaced
    fi
    let "n++"
done

# read in any new images
cd ./source/_static/images
imgFiles=([0-9][0-9][0-9]*)
cd ../../..

# check for any new images
if ! [[ ${imgFiles[0]} == "[0-9][0-9][0-9]*" ]]; then

# sort the new images
IFS=$'\n' imgFilesSorted=($(sort <<<"${imgFiles[*]}")); unset IFS
#printf "%s\n" "${imgFilesSorted[@]}"

      for sectionImage in "${imgFilesSorted[@]}"
        do
            # if a video metadata file
            if [[ ${imgFileSplit[1]} =~ /txt^/ ]]; then
              echo "future: video file optionsectionImage"

            # else if an image filesectionImage
            else
              # shrink large images to a max of 1024
              # todo: add check so that resize is applied only to large images
              #   https://stackoverflow.com/questions/38254297/bash-script-find-all-images-and-mogrify-images#38254569
              mogrify -path ./source/_static/images/ -resize "1024x1024" -quality 70 "./source/_static/images/${sectionImage}"

              # new_image_file_name = new_log_page_name.image_file_name
              imgFileName=$NEWLOGPAGE^${sectionImage}

              # rename the image from the original upload name to the new name
              mv "./source/_static/images/${sectionImage}" "./source/_static/images/${imgFileName}"
            fi
        done

fi


# read in any renamed images
cd ./source/_static/images
imgFilesRenamed=(${NEWLOGPAGE}*)
cd ../../..

# sort the renamed images
IFS=$'\n' imgFilesRenamedSorted=($(sort <<<"${imgFilesRenamed[*]}")); unset IFS
#printf "%s\n" "${imgFilesRenamedSorted[@]}"

#######################################################################################
# create the new Log Page file if it does not already exist
#  if it exists, delete manually and then re-run this script
# todo: add in menu choice (from zfs install)

### disable during development
#### check file existence
###if [ -f source/$NEWLOGPAGE.rst ]
###then
###    echo
###    echo The file exists: ./source/$NEWLOGPAGE.rst
###    echo Delete and try again
###    echo
###    exit 1
###fi



# No existing file so load the template
# Load the Log Page template file into array.
readarray -t logPageTemplateArray < log_page_template.txt

# overwrite the existing Log file and insert the first line of the template
echo "$templateOut" > ./source/$NEWLOGPAGE.rst

# Explicitly write the Log Page template out to file substitutung values
let i=0
while (( ${#logPageTemplateArray[@]} > i )); do
    templateOut=${logPageTemplateArray[i]}

    # replace marker with Title Tags (Sphinx include markers)
    if [[ $templateOut =~ "zzzTitleTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Title}
      echo "${templateOut//zzzTitleTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Title
    elif [[ $templateOut =~ "zzzTitlezzz" ]]; then
      echo "${templateOut//zzzTitlezzz/$logTitleSpaced}" >> ./source/$NEWLOGPAGE.rst
      printf_new "=" ${#logTitleSpaced} >> ./source/$NEWLOGPAGE.rst

    # replace marker with Log Link Tags (Sphinx include markers)
    elif [[ $templateOut =~ "zzzLogLinkTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Log_Link}
      echo "${templateOut//zzzLogLinkTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Log Page name
    elif [[ $templateOut =~ "zzzLogPageNamezzz" ]]; then
      echo "${templateOut//zzzLogPageNamezzz/$NEWLOGPAGE}" >> ./source/$NEWLOGPAGE.rst

    # replace marker with Teaser Test Tags (Sphinx include markers)
    elif [[ $templateOut =~ "zzzTeaserTagzzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Teaser}
      echo "${templateOut//zzzTeaserTagzzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    # build the teaser table with image
    # replace marker with Teaser image or video
    elif [[ $templateOut =~ "zzzTeaserImagezzz" ]]; then

      # evaluate file extension to determine if image or video metadata file
      IFS=', ' read -r -a imgFileSplit <<< "${imgFilesRenamedSorted[0]//./ }"

      # if a video metadata file
      if [[ ${imgFileSplit[1]} =~ /txt^/ ]]; then
        echo "future: video file option"kdx175.Engine.Prep_for_engine_removal.Log.20190714.0900.Main_Shopq.000           

      # else if an image file
      else
        # generate a new name for the image file
        # assume that the new files are name sequentially e.g. 000_*, 001_*, etc
        # todo: build name from date/time/OEM_name and/or metadata from thje pic ie 201909140901_IMG9327
        #       this will allow sort by date in the image viewer

        # new_image_file_name = new_log_page_name.image_file_name
        imgFileName=${imgFilesRenamedSorted[0]}

        # get the length of the new image name
        imgFileNameLength=${#imgFileName}

        # calculate the number of spaces needed to add to the name in order to make a legal table row
        spaceLength=$((120-${imgFileNameLength}))
        spaceLengthVar=$(printf ' %.0s' {$(seq 1 $spaceLength)})

        # print the new table row to the new log file
        echo "${templateOut//zzzTeaserImagezzz/$imgFileName}${spaceLengthVar}|" >> ./source/$NEWLOGPAGE.rst

        # rename the image from the original upload name to the new name
        #mv "./source/_static/images/${imgFilesSorted[0]}" "./source/_static/images/${imgFileName}"
      fi

    # replace marker with link to full-sized teaser image
    elif [[ $templateOut =~ "zzzTeaserILinkzzz" ]]; then
      echo "${templateOut//zzzTeaserILinkzzz/$imgFileName}${spaceLengthVar}|" >> ./source/$NEWLOGPAGE.rst

    # replace marker with a new section with an image or video
    elif [[ $templateOut =~ "zzzImageSectionzzz" ]]; then
      k=0

      for sectionImage in "${imgFilesRenamedSorted[@]}"
        do
          if [[ $k -gt 0 ]]; then
            echo "$k"
            echo "$sectionImage"

            # shrink large images to a max of 1024
            # todo: add check so that resize is applied only to large images
            #   https://stackoverflow.com/questions/38254297/bash-script-find-all-images-and-mogrify-images#38254569
            ###mogrify -path ./source/_static/images/ -resize "1024x1024" -quality 70 "./source/_static/images/${sectionImage}"

            # if a video metadata file
            if [[ ${imgFileSplit[1]} =~ /txt^/ ]]; then
              echo "future: video file option"

            # else if an image file
            else
              # new_image_file_name = new_log_page_name.image_file_name
              imgFileNameRtd=${sectionImage}

              # print the new section to the new log file
              echo "" >> ./source/$NEWLOGPAGE.rst

              # extract oem image file name to use for temporary title
              # break image name read from file system on each "---" and read into array
              IFS='^' read -a arrayTitle <<< "$imgFileNameRtd"; unset IFS
              titleFor="Section for your image ${arrayTitle[1]}"
              echo ${titleFor} >> ./source/$NEWLOGPAGE.rst
              printf_new "-" ${#titleFor} >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo ".. figure:: ./_static/images/${imgFileNameRtd}" >> ./source/$NEWLOGPAGE.rst
              echo "   :scale: 50%" >> ./source/$NEWLOGPAGE.rst
              echo "   :alt: ${sectionImage}" >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo "Caption for the image goes here" >> ./source/$NEWLOGPAGE.rst
              echo "" >> ./source/$NEWLOGPAGE.rst
              echo "   The legend consists of all elements after the caption.  In this" >> ./source/$NEWLOGPAGE.rst
              echo "   case, the legend consists of this paragraph." >> ./source/$NEWLOGPAGE.rst
              
              # rename the image from the original upload name to the new name
              #mv "./source/_static/images/${sectionImage}" "./source/_static/images/${imgFileName}"

              echo $imgFileNameRtd
            fi
          fi
          let "k++"
        done
    elif [[ $templateOut =~ "zzzTagPartsRowszzz" ]]; then
      NEWLOGPAGEUPDATED=${NEWLOGPAGE//Log/Parts}
      echo "${templateOut//zzzTagPartsRowszzz/$NEWLOGPAGEUPDATED}" >> ./source/$NEWLOGPAGE.rst

    else
      echo "$templateOut" >> ./source/$NEWLOGPAGE.rst
    fi
  let "i++"
done


#######################################################################################
# overwrite the Engine Logs Page file so that any new Logs are included

# Load the Engine Logs template file into array.
readarray -t engineLogsTemplateArray < engine_logs_template.txt

# read in Log file names
cd ./source
logFiles=(*\.Log\.*q.rst)
cd ..
#echo "${logFiles[@]}"

# sort array of Log file names
IFS=$'\n' logFilesSorted=($(sort <<<"${logFiles[*]}")); unset IFS
#printf "%s\n" "${logFilesSorted[@]}"

# fill array with the categories
n=0
for element in "${logFilesSorted[@]}"
  do
    # break input on each "."
    IFS='.' read -r -a arrayLogs <<< "$element"

    # read each category and insert into new array element
    imgCatagories[$n]=${arrayLogs[1]}
    let "n++"
  done

# remove duplicates from the array
readarray -td '' imgCatagoriesDeduped < <(
  printf '%s\0' "${imgCatagories[@]}" | LC_ALL=C sort -zu)

###echo ${imgCatagoriesDeduped[@]}

# for each category in de-duped array
n=0
for currentCategory in "${imgCatagoriesDeduped[@]}"
  do
  #echo ${currentCategory}

  # save the current Category Logs file (if it exists)
  mv ./source/${currentCategory}_logsqt.rst ./source/${currentCategory}_logsqt.rst.bak

  # Explicitly write the first 9 lines of the template out to the Category Logs file
  let i=0
  while (( i < 9 )); do
    templateOut=${engineLogsTemplateArray[i++]}
    echo "$templateOut" >> ./source/${currentCategory}_logsqt.rst
  done

  # for each Log File name already read in, act on those in the current category
  n=0
  for currentLogFileName in "${logFilesSorted[@]}"
    do
      # break input on each "."
      IFS='.' read -r -a currentLogFileNameParts <<< "$currentLogFileName"

      # read each category and insert into new array currentCategory
      currentLogCategory=${currentLogFileNameParts[1]}
      currentLogTitleUnSpaced=${currentLogFileNameParts[2]}

      # remove any underscores from the title
      currentLogTitleSpaced=${currentLogTitleUnSpaced//_/ }
      echo $currentLogTitleSpaced
      currentLogDate=${currentLogFileNameParts[4]}
      currentLogDateLong=$(date -d $currentLogDate +"%d-%b-%Y")

      # verify during testing
      #echo currentLogCategory=$currentLogCategory
      #echo currentLogTitleSpaced=$currentLogTitleSpaced
      #echo currentLogDateLong=$currentLogDateLong

      # it matches so add an entry to the Category Log file
      if [[ ${currentLogCategory} == ${currentCategory} ]]; then

      # append info for each Logs section starting with Engine then adding others
      # append new Log file info to the currentLogCategory Logs file (e.g. Engine Logs)
      currentLogTitleComplete="$currentLogDateLong --- $currentLogTitleSpaced"
      echo "$currentLogTitleComplete" >> ./source/${currentCategory}_logsqt.rst

      # draw line under title
      printf_new "-" ${#currentLogTitleComplete} >> ./source/${currentCategory}_logsqt.rst
      echo >> ./source/${currentCategory}_logsqt.rst

      # set name for include, start, stop
      currentLogFileNameUpdated=${currentLogFileName//Log/Title}
      currentLogFileNameUpdated=${currentLogFileNameUpdated//.rst/}

      # insert include, start, end into the currentLogCategory Logs file
      echo ".. include:: ${currentLogFileName}" >> ./source/${currentCategory}_logsqt.rst
      echo "  :start-after: .. START - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logsqt.rst
      echo "  :end-before: .. END - ${currentLogFileNameUpdated}" >> ./source/${currentCategory}_logsqt.rst

      # space for next entry
      echo >> ./source/engine_logsq.rst
      echo >> ./source/engine_logsq.rst

echo currentLogFileName=${currentLogFileName}
echo currentLogFileNameUpdated=${currentLogFileNameUpdated}
exit 1

      fi

      let "n++"
    done
  done